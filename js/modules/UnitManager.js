// Gestion centralis√©e des unit√©s pour GuildMaster
import { BASE_UNITS } from './UnitConstants.js';
import { ALL_UNITS } from './UnitConstants.js';
import { getTypeDisplayString } from '../utils/TypeUtils.js';
import { getRarityDisplayName, getRarityColor, getRarityIcon } from './RarityUtils.js';

// R√©cup√©rer seulement les unit√©s de base (quantity > 0)
export function getBaseUnits() {
    return BASE_UNITS.filter(unit => unit.quantity > 0);
}

// R√©cup√©rer toutes les unit√©s disponibles pour le magasin
export function getShopUnits() {
    return BASE_UNITS.filter(unit => unit.quantity === 0);
}

// R√©cup√©rer toutes les troupes disponibles dans le jeu
export function getAllAvailableTroops() {
    return ALL_UNITS;
}

// Obtenir les unit√©s poss√©d√©es pour la sauvegarde
export function getOwnedUnits(ownedUnits) {
    return ownedUnits;
}

// Charger les unit√©s poss√©d√©es depuis la sauvegarde
export function loadOwnedUnits(ownedUnits, gameState) {
    gameState.ownedUnits = ownedUnits || {};
    
    // Ne plus modifier BASE_UNITS, seulement ownedUnits
    // Les unit√©s sp√©ciales restent dans BASE_UNITS avec quantity = 0
    // mais sont compt√©es via ownedUnits
} 

// Extraire la cr√©ation du pool complet de troupes
function createFullTroopPool(gameState) {
    const fullTroopPool = [];
    
    // Utiliser ownedUnits pour les quantit√©s r√©elles
    BASE_UNITS.forEach(unit => {
        const quantity = gameState.ownedUnits[unit.name] || unit.quantity || 0;
        if (quantity > 0) {
            for (let i = 0; i < quantity; i++) {
                fullTroopPool.push({...unit, id: `${unit.name}_${i}`});
            }
        }
    });

    // Ajouter les troupes achet√©es dans le magasin
    return [
        ...fullTroopPool,
        ...gameState.availableTroops
    ];
}

// Extraire le groupement des troupes par type
function groupTroopsByType(allTroops) {
    const troopsByType = {};
    allTroops.forEach(troop => {
        if (!troopsByType[troop.name]) {
            troopsByType[troop.name] = {
                count: 0,
                damage: troop.damage,
                multiplier: troop.multiplier,
                type: troop.unitType || troop.type,
                icon: troop.icon,
                rarity: troop.rarity
            };
        }
        troopsByType[troop.name].count++;
    });
    return troopsByType;
}

// Extraire l'ajustement des compteurs pour les unit√©s transform√©es
function adjustTransformedUnitsCount(troopsByType, gameState) {
    Object.keys(gameState.transformedBaseUnits).forEach(unitName => {
        if (troopsByType[unitName]) {
            troopsByType[unitName].count = Math.max(0, troopsByType[unitName].count - gameState.transformedBaseUnits[unitName]);
        }
    });
}

// Extraire la cr√©ation d'une ic√¥ne de troupe avec tooltip
function createTroopIcon(troopName, troopData) {
    const rarityClass = troopData.rarity ? `rarity-${troopData.rarity}` : '';
    const classes = ['troop-icon-header'];
    if (rarityClass) classes.push(rarityClass);
    
    const troopElement = document.createElement('div');
    troopElement.className = classes.join(' ');
    troopElement.setAttribute('data-count', troopData.count);
    troopElement.setAttribute('data-troop-name', troopName);
    
    const typeDisplay = getTypeDisplayString(troopData.type);
    const rarityDisplay = troopData.rarity ? getRarityDisplayName(troopData.rarity) : '';
    
    // Chiffres color√©s pour d√©g√¢ts et multiplicateur
    const damageColored = `<span class='troop-damage-tooltip'>${troopData.damage}</span>`;
    const multiColored = `<span class='troop-mult-tooltip'>${troopData.multiplier}</span>`;
    
    // Cr√©er le tooltip avec les informations de l'unit√©
    const tooltipContent = `
        <strong>${troopName}</strong><br>
        ${damageColored} √ó ${multiColored}<br>
        üè∑Ô∏è ${typeDisplay}<br>
        ${rarityDisplay ? `‚≠ê ${rarityDisplay}` : ''}
    `;
    
    troopElement.innerHTML = `
        ${troopData.icon}
        <div class="troop-tooltip">${tooltipContent}</div>
    `;
    
    return troopElement;
}

// Extraire la cr√©ation de toutes les ic√¥nes de troupes
function createTroopIcons(troopsByType) {
    const troopElements = [];
    
    Object.keys(troopsByType).forEach(troopName => {
        const troopData = troopsByType[troopName];
        if (troopData.count > 0) {
            const troopElement = createTroopIcon(troopName, troopData);
            troopElements.push(troopElement);
        }
    });
    
    return troopElements;
}

// Afficher les troupes dans le header
export function updateTroopsDisplay(gameState) {
    const troopsContainer = document.getElementById('troops-display');
    if (!troopsContainer) return;

    troopsContainer.innerHTML = '';

    // Cr√©er un pool complet de toutes les troupes disponibles
    const allTroops = createFullTroopPool(gameState);

    // Grouper les troupes par nom
    const troopsByType = groupTroopsByType(allTroops);

    // Ajuster les compteurs pour les unit√©s de base transform√©es
    adjustTransformedUnitsCount(troopsByType, gameState);

    // Cr√©er les ic√¥nes pour chaque type de troupe
    const troopElements = createTroopIcons(troopsByType);
    
    // Ajouter les √©l√©ments au conteneur
    troopElements.forEach(element => {
        troopsContainer.appendChild(element);
    });
} 

// Ajouter une troupe √† la liste des troupes disponibles
export function addTroop(troop, gameState) {
    gameState.availableTroops.push(troop);
    gameState.updateTroopsUI();
} 

// Tirer 7 troupes al√©atoirement pour le combat
export function drawCombatTroops(gameState) {
    // Ne pas r√©g√©n√©rer les troupes si elles existent d√©j√† (pour la sauvegarde)
    if (gameState.combatTroops && gameState.combatTroops.length > 0) {
        gameState.updateTroopsUI();
        return;
    }
    
    gameState.combatTroops = [];
    // Ne pas vider selectedTroops ici, seulement les troupes de combat
    // gameState.selectedTroops = [];
    
    // Cr√©er un pool de troupes avec toutes les unit√©s poss√©d√©es (ownedUnits)
    const troopPool = [];
    BASE_UNITS.forEach(unit => {
        // Calculer la quantit√© disponible en tenant compte des transformations
        let quantity = gameState.ownedUnits[unit.name] || unit.quantity || 0;
        
        // Retirer les unit√©s transform√©es
        const transformedCount = gameState.transformedBaseUnits[unit.name] || 0;
        quantity = Math.max(0, quantity - transformedCount);
        
        // Ajouter seulement les unit√©s non transform√©es
        for (let i = 0; i < quantity; i++) {
            troopPool.push({...unit, id: `${unit.name}_${i}`});
        }
    });
    
    // Ajouter les unit√©s achet√©es/transform√©es depuis availableTroops
    gameState.availableTroops.forEach(troop => {
        troopPool.push({...troop});
    });
    

    
    // Tirer 7 troupes al√©atoirement
    for (let i = 0; i < 7 && troopPool.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * troopPool.length);
        gameState.combatTroops.push(troopPool.splice(randomIndex, 1)[0]);
    }
    
            gameState.updateTroopsUI();
} 

// Maintenir 7 troupes disponibles en tirant de nouvelles troupes
export function maintainCombatTroops(gameState) {
    // Cr√©er un pool complet de troupes avec toutes les unit√©s poss√©d√©es (ownedUnits)
    const fullTroopPool = [];
    BASE_UNITS.forEach(unit => {
        // Calculer la quantit√© disponible en tenant compte des transformations
        let quantity = gameState.ownedUnits[unit.name] || unit.quantity || 0;
        
        // Retirer les unit√©s transform√©es
        const transformedCount = gameState.transformedBaseUnits[unit.name] || 0;
        quantity = Math.max(0, quantity - transformedCount);
        
        // Ajouter seulement les unit√©s non transform√©es
        for (let i = 0; i < quantity; i++) {
            fullTroopPool.push({...unit, id: `${unit.name}_${i}`});
        }
    });
    
    // Ajouter les unit√©s achet√©es/transform√©es depuis availableTroops
    gameState.availableTroops.forEach(troop => {
        fullTroopPool.push({...troop});
    });
    

    
    // Retirer les troupes d√©j√† utilis√©es dans ce rang
    const availableTroops = fullTroopPool.filter(troop => 
        !gameState.usedTroopsThisRank.includes(troop.id)
    );
    
    // Retirer les troupes d√©j√† dans le pool de combat
    const remainingTroops = availableTroops.filter(troop => 
        !gameState.combatTroops.some(combatTroop => combatTroop.id === troop.id)
    );
    
    // Ajouter des troupes jusqu'√† avoir 7 disponibles
    while (gameState.combatTroops.length < 7 && remainingTroops.length > 0) {
        const randomIndex = Math.floor(Math.random() * remainingTroops.length);
        const newTroop = remainingTroops.splice(randomIndex, 1)[0];
        gameState.combatTroops.push(newTroop);
    }
} 

// V√©rifier si une unit√© est permanente (achet√©e ou transform√©e)
export function isPermanentUnit(troop) {
    // Les unit√©s de base ont des IDs avec un format sp√©cifique (nom_index)
    // Les unit√©s achet√©es/transform√©es ont des IDs uniques avec timestamp
    return !troop.id.includes('_') || troop.id.split('_').length > 2;
} 

// V√©rifier si une troupe a un type sp√©cifique
export function hasTroopType(troop, targetType) {
    if (Array.isArray(troop.type)) {
        return troop.type.includes(targetType);
    }
    return troop.type === targetType;
}

// Relancer les troupes s√©lectionn√©es (les retirer du pool de combat et les remplacer par de nouvelles)
export function rerollSelectedTroops(gameState) {
    // V√©rifier si le malus de Quilegan est actif
    const isQuileganActive = gameState.currentCombat && 
                            gameState.currentCombat.isBossFight && 
                            gameState.currentCombat.bossName === 'Quilegan' &&
                            !gameState.bossManager.isBossMalusDisabled();
    
    if (isQuileganActive) {
        gameState.notificationManager.showNotification('Relance bloqu√©e par Quilegan - Vendez un bonus pour d√©bloquer !', 'warning');
        return;
    }
    
    // V√©rifier le nombre de relances restantes
    if (!gameState.rerollCount) {
        gameState.rerollCount = 0;
    }
    
    if (gameState.rerollCount >= 3) {
        gameState.notificationManager.showNotification('Vous avez atteint la limite de 3 relances maximum !', 'warning');
        return;
    }
    
    // Filtrer les troupes s√©lectionn√©es qui peuvent √™tre relanc√©es
    const troopsToReroll = gameState.selectedTroops.filter(troop => {
        // V√©rifier si la troupe est dans le pool de combat
        const isInCombatPool = gameState.combatTroops.some(t => t.id === troop.id);
        // V√©rifier si la troupe n'est pas utilis√©e
        const isNotUsed = !gameState.usedTroopsThisRank.includes(troop.id);
        return isInCombatPool && isNotUsed;
    });
    
    if (troopsToReroll.length === 0) {
        gameState.notificationManager.showNotification('Aucune troupe s√©lectionn√©e peut √™tre relanc√©e !', 'warning');
        return;
    }
    
    // Cr√©er un pool de troupes disponibles pour les remplacements
    const availablePool = [];
    BASE_UNITS.forEach(unit => {
        // Calculer la quantit√© disponible en tenant compte des transformations
        let quantity = gameState.ownedUnits[unit.name] || unit.quantity || 0;
        
        // Retirer les unit√©s transform√©es
        const transformedCount = gameState.transformedBaseUnits[unit.name] || 0;
        quantity = Math.max(0, quantity - transformedCount);
        
        // Ajouter seulement les unit√©s non transform√©es
        for (let i = 0; i < quantity; i++) {
            availablePool.push({...unit, id: `${unit.name}_${i}`});
        }
    });
    
    // Ajouter les unit√©s achet√©es/transform√©es depuis availableTroops
    gameState.availableTroops.forEach(troop => {
        availablePool.push({...troop});
    });
    
    // Retirer les troupes d√©j√† dans le pool de combat
    const remainingTroops = availablePool.filter(t => 
        !gameState.combatTroops.some(combatTroop => combatTroop.id === t.id)
    );
    
    // Retirer les troupes d√©j√† utilis√©es dans ce rang
    const unusedTroops = remainingTroops.filter(t => 
        !gameState.usedTroopsThisRank.includes(t.id)
    );
    
    let rerolledCount = 0;
    const rerolledTroops = [];
    
    // Relancer chaque troupe s√©lectionn√©e
    troopsToReroll.forEach(troop => {
        // Retirer la troupe du pool de combat
        const combatTroopIndex = gameState.combatTroops.findIndex(t => t.id === troop.id);
        if (combatTroopIndex !== -1) {
            gameState.combatTroops.splice(combatTroopIndex, 1);
        }
        
        // Retirer la troupe de la s√©lection
        const selectedIndex = gameState.selectedTroops.findIndex(t => t.id === troop.id);
        if (selectedIndex !== -1) {
            gameState.selectedTroops.splice(selectedIndex, 1);
        }
        
        // Ajouter la troupe relanc√©e √† la liste des troupes utilis√©es dans ce rang
        gameState.usedTroopsThisRank.push(troop.id);
        
        // Tirer une nouvelle troupe au hasard
        if (unusedTroops.length > 0) {
            const randomIndex = Math.floor(Math.random() * unusedTroops.length);
            const newTroop = unusedTroops.splice(randomIndex, 1)[0];
            gameState.combatTroops.push(newTroop);
            
            rerolledTroops.push({ from: troop.name, to: newTroop.name });
            rerolledCount++;
        }
    });
    
    // Incr√©menter le compteur de relances
    gameState.rerollCount++;
    
    // Afficher une notification avec le r√©sum√© des relances
    if (rerolledCount > 0) {
        const rerollText = rerolledTroops.map(r => `${r.from} ‚Üí ${r.to}`).join(', ');
        gameState.notificationManager.showNotification(`Relance ${gameState.rerollCount}/3 : ${rerollText}`, 'info');
    } else {
        gameState.notificationManager.showNotification('Aucune troupe disponible pour le remplacement', 'warning');
    }
    
    // Mettre √† jour l'interface
    gameState.updateTroopsUI();
    gameState.updateSynergies();
    
    // Mettre √† jour l'affichage du bouton de relance
    if (gameState.unitSorter) {
        gameState.unitSorter.updateRerollButton();
    }
}

// S√©lectionner une troupe pour le combat (max 5)
export function selectTroopForCombat(troopIndex, gameState) {
    if (gameState.selectedTroops.length >= 5) {
        gameState.notificationManager.showUnitSelectionError('Vous ne pouvez s√©lectionner que 5 troupes maximum !');
        return;
    }
    
    // Obtenir toutes les troupes disponibles
    const allAvailableTroops = [...gameState.combatTroops, ...gameState.availableTroops];
    
    if (troopIndex >= 0 && troopIndex < allAvailableTroops.length) {
        const troop = allAvailableTroops[troopIndex];
        
        // V√©rifier si la troupe n'est pas d√©j√† s√©lectionn√©e
        const alreadySelected = gameState.selectedTroops.some(t => t.id === troop.id);
        if (alreadySelected) {
            gameState.notificationManager.showUnitSelectionError('Cette troupe est d√©j√† s√©lectionn√©e !');
            return;
        }
        
        // Ajouter la troupe √† la s√©lection sans la retirer de la liste disponible
        gameState.selectedTroops.push(troop);
        gameState.updateTroopsUI();
        gameState.updateSynergies();
    }
} 

// D√©s√©lectionner une troupe du combat
export function deselectTroopFromCombat(troopIndex, gameState) {
    if (troopIndex >= 0 && troopIndex < gameState.selectedTroops.length) {
        const troop = gameState.selectedTroops.splice(troopIndex, 1)[0];
        
        // La troupe reste dans la liste disponible, pas besoin de la remettre
        gameState.updateTroopsUI();
        gameState.updateSynergies();
    }
} 

// Retirer les troupes utilis√©es de la s√©lection ET du pool de combat
export function removeUsedTroopsFromCombat(troopsUsed, gameState) {
    troopsUsed.forEach(usedTroop => {
        // Retirer de la s√©lection
        const selectedIndex = gameState.selectedTroops.findIndex(troop => troop.id === usedTroop.id);
        if (selectedIndex !== -1) {
            gameState.selectedTroops.splice(selectedIndex, 1);
        }
        
        // Retirer du pool de combat
        const combatIndex = gameState.combatTroops.findIndex(troop => troop.id === usedTroop.id);
        if (combatIndex !== -1) {
            gameState.combatTroops.splice(combatIndex, 1);
        }
        
        // Si c'est une unit√© achet√©e/transform√©e (permanente), la remettre seulement dans availableTroops
        if (isPermanentUnit(usedTroop)) {
            // V√©rifier qu'elle n'est pas d√©j√† dans availableTroops
            const existingAvailableIndex = gameState.availableTroops.findIndex(troop => troop.id === usedTroop.id);
            if (existingAvailableIndex === -1) {
                gameState.availableTroops.push(usedTroop);
            }
            // NE PAS remettre dans combatTroops pour √©viter qu'elle apparaisse automatiquement
        }
    });
    
    // Maintenir 7 troupes disponibles en ajoutant de nouvelles troupes (seulement pour les unit√©s temporaires)
    maintainCombatTroops(gameState);
    
    gameState.updateTroopsUI();
    gameState.updateSynergies();
} 

// Mettre √† jour l'interface des troupes disponibles
export function updateTroopsUI(gameState) {
    const availableContainer = document.getElementById('available-troops');
    if (!availableContainer) {
        console.error('Containers non trouv√©s');
        return;
    }
    availableContainer.innerHTML = '';
    

    
    // Afficher toutes les troupes disponibles (combat + achet√©es)
    const allAvailableTroops = [...gameState.combatTroops, ...gameState.availableTroops]

    
    allAvailableTroops.forEach((troop, index) => {
        // V√©rifier si cette troupe est s√©lectionn√©e
        const isSelected = gameState.selectedTroops.some(selectedTroop => selectedTroop.id === troop.id);
        const troopCard = createTroopCard(troop, index, isSelected, gameState);
        availableContainer.appendChild(troopCard);
    });

    // Mettre √† jour les titres des sections (sans le nombre de troupes disponibles)
    const availableTitle = availableContainer.parentElement.querySelector('h4');
    
    if (availableTitle) {
        availableTitle.textContent = `Troupes Disponibles`;
    }
}

// Extraire la logique de cr√©ation des classes CSS pour les cartes de troupes
function createTroopCardClasses(troop, isSelected, isUsed) {
    const classes = ['unit-card'];
    if (isSelected) classes.push('selected');
    if (isUsed) classes.push('used');
    if (troop.rarity) classes.push(`rarity-${troop.rarity}`);
    return classes.join(' ');
}

// Extraire la logique de style de raret√©
function applyRarityStyling(card, troop) {
    if (!troop.rarity) return;
    
    const rarityColors = {
        'common': 'linear-gradient(135deg, rgba(102, 102, 102, 0.1) 0%, rgba(102, 102, 102, 0.05) 100%)',
        'uncommon': 'linear-gradient(135deg, rgba(0, 184, 148, 0.1) 0%, rgba(0, 184, 148, 0.05) 100%)',
        'rare': 'linear-gradient(135deg, rgba(116, 185, 255, 0.1) 0%, rgba(116, 185, 255, 0.05) 100%)',
        'epic': 'linear-gradient(135deg, rgba(162, 155, 254, 0.1) 0%, rgba(162, 155, 254, 0.05) 100%)',
        'legendary': 'linear-gradient(135deg, rgba(253, 203, 110, 0.1) 0%, rgba(253, 203, 110, 0.05) 100%)'
    };
    
    card.style.background = rarityColors[troop.rarity];
    card.style.borderColor = getRarityColor(troop.rarity);
}

// Extraire la g√©n√©ration du HTML de la carte
function generateTroopCardHTML(troop, isUsed) {
    const typeDisplay = getTypeDisplayString(troop.type);
    const rarityHTML = troop.rarity ? 
        `<div class="unit-rarity" style="color: ${getRarityColor(troop.rarity)}; font-weight: 600; margin-top: 5px; font-size: 0.8rem;">
            ${getRarityIcon(troop.rarity)} ${getRarityDisplayName(troop.rarity)}
        </div>` : '';
    
    const usedHTML = isUsed ? '<div class="unit-used">Utilis√©e</div>' : '';
    
    return `
        <div class="unit-icon">${troop.icon}</div>
        <div class="unit-name">${troop.name}</div>
        <div class="unit-stats"><span class="unit-damage">${troop.damage}</span> √ó <span class="unit-multiplier">${troop.multiplier}</span></div>
        <div class="unit-type">${typeDisplay}</div>
        ${rarityHTML}
        ${usedHTML}
    `;
}

// Extraire la logique d'√©v√©nements de la carte
function attachTroopCardEvents(card, troop, troopId, isSelected, isUsed, gameState) {
    card.addEventListener('click', () => {
        if (isUsed) {
            gameState.notificationManager.showUnitUsedError('Cette troupe a d√©j√† √©t√© utilis√©e dans ce rang !');
            return;
        }
        
        if (isSelected) {
            // Trouver l'index dans selectedTroops pour la d√©s√©lection
            const selectedIndex = gameState.selectedTroops.findIndex(t => t.id === troop.id);
            if (selectedIndex !== -1) {
                gameState.deselectTroopFromCombat(selectedIndex);
            }
        } else {
            // Utiliser l'ID de la troupe pour la s√©lection
            gameState.selectTroopById(troop.id);
        }
    });
}

export function createTroopCard(troop, index, isSelected, gameState) {
    const card = document.createElement('div');
    const isUsed = gameState.usedTroopsThisRank.includes(troop.id);
    
    // Appliquer les classes CSS
    card.className = createTroopCardClasses(troop, isSelected, isUsed);
    

    
    // Appliquer le style de raret√©
    applyRarityStyling(card, troop);
    
    // G√©n√©rer le HTML
    card.innerHTML = generateTroopCardHTML(troop, isUsed);
    
    // Attacher les √©v√©nements
    attachTroopCardEvents(card, troop, index, isSelected, isUsed, gameState);

    return card;
} 

// Mettre √† jour l'affichage des synergies
export function updateSynergies(gameState) {
    const synergiesContainer = document.getElementById('synergies-display');
    if (!synergiesContainer) {
        console.warn('Container synergies-display non trouv√©');
        return;
    }

    // Vider le conteneur AVANT d'ajouter de nouveaux √©l√©ments
    synergiesContainer.innerHTML = '';

    // Utiliser UNIQUEMENT les troupes s√©lectionn√©es pour les synergies
    let troopsToAnalyze = gameState.selectedTroops;
    
    // Si aucune troupe n'est s√©lectionn√©e, afficher un message
    if (troopsToAnalyze.length === 0) {
        synergiesContainer.innerHTML = '<p class="no-synergies">S√©lectionnez des unit√©s pour voir les synergies</p>';
        return;
    }

    const synergies = gameState.calculateSynergies(troopsToAnalyze);
    
    if (synergies.length === 0) {
        synergiesContainer.innerHTML = '<p class="no-synergies">Aucune synergie active avec cette composition</p>';
        return;
    }

    // Ajouter les synergies une par une
    synergies.forEach(synergy => {
        const synergyElement = document.createElement('div');
        synergyElement.className = 'synergy-item';
        synergyElement.innerHTML = `
            <div class="synergy-name">${synergy.name}</div>
            <div class="synergy-effect">${synergy.description}</div>
        `;
        synergiesContainer.appendChild(synergyElement);
    });
} 

// Calculer les synergies entre les troupes
export function calculateSynergies(troops = null, gameState) {
    const synergies = [];
    
    // Utiliser les troupes pass√©es en param√®tre ou les troupes s√©lectionn√©es
    const troopsToCheck = troops || gameState.selectedTroops;
    
    // Compter les types de troupes
    const typeCounts = {};
    troopsToCheck.forEach(troop => {
        if (Array.isArray(troop.type)) {
            troop.type.forEach(type => {
                typeCounts[type] = (typeCounts[type] || 0) + 1;
            });
        } else {
            typeCounts[troop.type] = (typeCounts[troop.type] || 0) + 1;
        }
    });

    // --- SYNERGIE SOIGNEUR ---
    const healerCount = typeCounts['Soigneur'] || 0;
    if (healerCount > 0) {
        synergies.push({
            name: 'Pr√©sence de Soigneur',
            description: `+${healerCount} d√©g√¢ts pour toute l'√©quipe (Soigneur)`,
            bonus: { damage: healerCount, target: 'all' },
            level: healerCount
        });
    }

    // --- SAINTE TRINIT√â ---
    const meleeCount = typeCounts['Corps √† corps'] || 0;
    const rangedCount = typeCounts['Distance'] || 0;
    if (meleeCount >= 1 && rangedCount >= 1 && healerCount >= 1) {
        synergies.push({
            name: 'Sainte Trinit√©',
            description: '+2 d√©g√¢ts et +2 multiplicateur pour toute l\'√©quipe',
            bonus: { damage: 2, multiplier: 2, target: 'all' },
            level: 1
        });
    }

    // Synergies de base (augment√©es)
    if (typeCounts['Corps √† corps'] >= 3) {
        const level = gameState.synergyLevels['Formation Corps √† Corps'] || 1;
        const multiplierBonus = 2 + (level - 1); // +2 au niveau 1, +3 au niveau 2, etc.
        synergies.push({
            name: 'Formation Corps √† Corps',
            description: `+${multiplierBonus} multiplicateur pour toutes les unit√©s corps √† corps (Niveau ${level})`,
            bonus: { multiplier: multiplierBonus, target: 'Corps √† corps' },
            level: level
        });
    }
    
    if (typeCounts['Distance'] >= 3) {
        const level = gameState.synergyLevels['Formation Distance'] || 1;
        const multiplierBonus = 3 + (level - 1); // +3 au niveau 1, +4 au niveau 2, etc.
        synergies.push({
            name: 'Formation Distance',
            description: `+${multiplierBonus} multiplicateur pour toutes les unit√©s distance (Niveau ${level})`,
            bonus: { multiplier: multiplierBonus, target: 'Distance' },
            level: level
        });
    }
    
    if (typeCounts['Magique'] >= 3) {
        const level = gameState.synergyLevels['Formation Magique'] || 1;
        const multiplierBonus = 4 + (level - 1); // +4 au niveau 1, +5 au niveau 2, etc.
        synergies.push({
            name: 'Formation Magique',
            description: `+${multiplierBonus} multiplicateur pour toutes les unit√©s magiques (Niveau ${level})`,
            bonus: { multiplier: multiplierBonus, target: 'Magique' },
            level: level
        });
    }

    // Synergies avanc√©es (nouvelles et plus puissantes)
    if (typeCounts['Corps √† corps'] >= 5) {
        const level = gameState.synergyLevels['Horde Corps √† Corps'] || 1;
        const damageBonus = 5 + (level - 1); // +5 au niveau 1, +6 au niveau 2, etc.
        const multiplierBonus = 3 + (level - 1); // +3 au niveau 1, +4 au niveau 2, etc.
        synergies.push({
            name: 'Horde Corps √† Corps',
            description: `+${damageBonus} d√©g√¢ts et +${multiplierBonus} multiplicateur pour toutes les unit√©s corps √† corps (Niveau ${level})`,
            bonus: { damage: damageBonus, multiplier: multiplierBonus, target: 'Corps √† corps' },
            level: level
        });
    }
    
    if (typeCounts['Distance'] >= 5) {
        const level = gameState.synergyLevels['Vol√©e de Fl√®ches'] || 1;
        const damageBonus = 8 + (level - 1); // +8 au niveau 1, +9 au niveau 2, etc.
        const multiplierBonus = 4 + (level - 1); // +4 au niveau 1, +5 au niveau 2, etc.
        synergies.push({
            name: 'Vol√©e de Fl√®ches',
            description: `+${damageBonus} d√©g√¢ts et +${multiplierBonus} multiplicateur pour toutes les unit√©s distance (Niveau ${level})`,
            bonus: { damage: damageBonus, multiplier: multiplierBonus, target: 'Distance' },
            level: level
        });
    }
    
    if (typeCounts['Magique'] >= 5) {
        const level = gameState.synergyLevels['Temp√™te Magique'] || 1;
        const damageBonus = 10 + (level - 1); // +10 au niveau 1, +11 au niveau 2, etc.
        const multiplierBonus = 5 + (level - 1); // +5 au niveau 1, +6 au niveau 2, etc.
        synergies.push({
            name: 'Temp√™te Magique',
            description: `+${damageBonus} d√©g√¢ts et +${multiplierBonus} multiplicateur pour toutes les unit√©s magiques (Niveau ${level})`,
            bonus: { damage: damageBonus, multiplier: multiplierBonus, target: 'Magique' },
            level: level
        });
    }

    // Synergies mixtes (nouvelles)
    if (typeCounts['Corps √† corps'] >= 3 && typeCounts['Distance'] >= 3) {
        const level = gameState.synergyLevels['Tactique Mixte'] || 1;
        const damageBonus = 3 + (level - 1); // +3 au niveau 1, +4 au niveau 2, etc.
        synergies.push({
            name: 'Tactique Mixte',
            description: `+${damageBonus} d√©g√¢ts pour toutes les unit√©s (Niveau ${level})`,
            bonus: { damage: damageBonus, target: 'all' },
            level: level
        });
    }
    
    if (typeCounts['Physique'] >= 6) {
        const level = gameState.synergyLevels['Force Physique'] || 1;
        const damageBonus = 4 + (level - 1); // +4 au niveau 1, +5 au niveau 2, etc.
        synergies.push({
            name: 'Force Physique',
            description: `+${damageBonus} d√©g√¢ts pour toutes les unit√©s physiques (Niveau ${level})`,
            bonus: { damage: damageBonus, target: 'Physique' },
            level: level
        });
    }

    return synergies;
} 

// Calculer les bonus d'√©quipement
export function calculateEquipmentBonuses(gameState) {
    const bonuses = [];
    const bonusDescriptions = gameState.getBonusDescriptions();
    
    // Compter les occurrences de chaque bonus
    const bonusCounts = {};
    gameState.unlockedBonuses.forEach(bonusId => {
        bonusCounts[bonusId] = (bonusCounts[bonusId] || 0) + 1;
    });
    
    // Appliquer les bonus d'√©quipement
    Object.keys(bonusCounts).forEach(bonusId => {
        const count = bonusCounts[bonusId];
        const bonusDesc = bonusDescriptions[bonusId];
        
        if (!bonusDesc) {
            console.warn(`Bonus non trouv√© dans les descriptions: ${bonusId}`);
            return;
        }
        
        // Bonus de d√©g√¢ts pour corps √† corps
        if (bonusId === 'epee_aiguisee') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 2 * count, 
                target: 'Corps √† corps' 
            });
        }
        // Bonus de d√©g√¢ts pour distance
        else if (bonusId === 'arc_renforce') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 2 * count, 
                target: 'Distance' 
            });
        }
        // Bonus de d√©g√¢ts pour magique
        else if (bonusId === 'grimoire_magique') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 2 * count, 
                target: 'Magique' 
            });
        }
        // Bonus de multiplicateur pour corps √† corps
        else if (bonusId === 'amulette_force') {
            bonuses.push({ 
                name: bonusDesc.name,
                multiplier: 1 * count, 
                target: 'Corps √† corps' 
            });
        }
        // Bonus de multiplicateur pour distance
        else if (bonusId === 'cristal_precision') {
            bonuses.push({ 
                name: bonusDesc.name,
                multiplier: 1 * count, 
                target: 'Distance' 
            });
        }
        // Bonus de multiplicateur pour magique
        else if (bonusId === 'orbe_mystique') {
            bonuses.push({ 
                name: bonusDesc.name,
                multiplier: 1 * count, 
                target: 'Magique' 
            });
        }
        // Bonus l√©gendaires corps √† corps
        else if (bonusId === 'armure_legendaire') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 5 * count, 
                multiplier: 2 * count, 
                target: 'Corps √† corps' 
            });
        }
        // Bonus l√©gendaires distance
        else if (bonusId === 'arc_divin') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 5 * count, 
                multiplier: 2 * count, 
                target: 'Distance' 
            });
        }
        // Bonus l√©gendaires magique
        else if (bonusId === 'baguette_supreme') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 5 * count, 
                multiplier: 2 * count, 
                target: 'Magique' 
            });
        }
        // Bonus pour toutes les unit√©s
        else if (bonusId === 'potion_force') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 3 * count, 
                target: 'all' 
            });
        }
        else if (bonusId === 'elixir_puissance') {
            bonuses.push({ 
                name: bonusDesc.name,
                multiplier: 1 * count, 
                target: 'all' 
            });
        }
        else if (bonusId === 'relique_ancienne') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 10 * count, 
                multiplier: 3 * count, 
                target: 'all' 
            });
        }
        // Bonus dynamiques avec effets multiples
        else if (bonusId === 'cac_cest_la_vie') {
            const dynamicBonus = calculateDynamicBonus(bonusDesc, gameState, bonusId);
            if (dynamicBonus) {
                bonuses.push(dynamicBonus);
            }
        }
        // Bonus de base pour corps √† corps
        else if (bonusId === 'corps_a_corps_bonus') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 10 * count, 
                target: 'Corps √† corps' 
            });
        }
        // Bonus de base pour distance
        else if (bonusId === 'distance_bonus') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 10 * count, 
                target: 'Distance' 
            });
        }
        // Bonus de base pour magique
        else if (bonusId === 'magique_bonus') {
            bonuses.push({ 
                name: bonusDesc.name,
                damage: 10 * count, 
                target: 'Magique' 
            });
        }
    });
    
    return bonuses;
}

// Calculer les bonus dynamiques avec effets multiples
export function calculateDynamicBonus(bonusDesc, gameState, bonusId) {
    if (!bonusDesc.effects) {
        return null;
    }
    
    let totalValue = 0;
    let target = null;
    
    bonusDesc.effects.forEach(effect => {
        if (effect.condition === 'base') {
            // Effet de base : toujours appliqu√©
            totalValue += effect.value;
            target = effect.target;
        }
        else if (effect.condition === 'synergy_trigger') {
            // Effet d√©clench√© par synergie
            let triggerCount = 0;
            
            // R√©cup√©rer le compteur depuis les √©tats sauvegard√©s
            if (gameState.dynamicBonusStates && 
                gameState.dynamicBonusStates[bonusId] && 
                gameState.dynamicBonusStates[bonusId][effect.triggerSynergy]) {
                triggerCount = gameState.dynamicBonusStates[bonusId][effect.triggerSynergy];
                console.log(`üéØ calculateDynamicBonus: Compteur r√©cup√©r√© depuis sauvegarde pour ${bonusId}.${effect.triggerSynergy} = ${triggerCount}`);
            } else {
                // Fallback vers le compteur local si pas de sauvegarde
                triggerCount = effect.triggerCount || 0;
                console.log(`üéØ calculateDynamicBonus: Compteur local utilis√© pour ${bonusId}.${effect.triggerSynergy} = ${triggerCount}`);
            }
            
            totalValue += effect.value * triggerCount;
            target = effect.target;
        }
    });
    
    if (totalValue > 0 && target) {
        return {
            name: bonusDesc.name,
            multiplier: totalValue,
            target: target === 'melee_units' ? 'Corps √† corps' : target
        };
    }
    
        return null;
}

// Incr√©menter le compteur d'un bonus dynamique quand une synergie se d√©clenche
export function incrementDynamicBonusTrigger(bonusId, triggerSynergy, gameState) {
    // V√©rifier si le bonus est d√©bloqu√©
    if (!gameState.unlockedBonuses.includes(bonusId)) {
        return;
    }
    
    // R√©cup√©rer la description du bonus
    const bonusDescriptions = gameState.getBonusDescriptions();
    const bonusDesc = bonusDescriptions[bonusId];
    
    if (!bonusDesc || !bonusDesc.effects) {
        return;
    }
    
    // Trouver l'effet avec le trigger correspondant
    const triggerEffect = bonusDesc.effects.find(effect => 
        effect.condition === 'synergy_trigger' && 
        effect.triggerSynergy === triggerSynergy
    );
    
    if (triggerEffect) {
        // V√©rifier si ce bonus a d√©j√† √©t√© incr√©ment√© ce round
        const roundKey = `round_${gameState.currentCombat.round || 1}`;
        const bonusRoundKey = `${bonusId}_${triggerSynergy}_${roundKey}`;
        
        if (gameState.dynamicBonusTriggers && gameState.dynamicBonusTriggers[bonusRoundKey]) {
            // D√©j√† incr√©ment√© ce round, ne rien faire
            console.log(`üéØ incrementDynamicBonusTrigger: D√©j√† incr√©ment√© ce round pour ${bonusId}.${triggerSynergy}`);
            return;
        }
        
        // R√©cup√©rer le compteur actuel depuis les √©tats sauvegard√©s
        let currentCount = 0;
        if (gameState.dynamicBonusStates && 
            gameState.dynamicBonusStates[bonusId] && 
            gameState.dynamicBonusStates[bonusId][triggerSynergy]) {
            currentCount = gameState.dynamicBonusStates[bonusId][triggerSynergy];
            console.log(`üéØ incrementDynamicBonusTrigger: Compteur actuel depuis sauvegarde = ${currentCount}`);
        } else {
            currentCount = triggerEffect.triggerCount || 0;
            console.log(`üéØ incrementDynamicBonusTrigger: Compteur actuel depuis effet = ${currentCount}`);
        }
        
        // Incr√©menter le compteur
        const newCount = currentCount + 1;
        triggerEffect.triggerCount = newCount;
        
        // Sauvegarder l'√©tat du bonus dynamique
        if (!gameState.dynamicBonusStates) {
            gameState.dynamicBonusStates = {};
        }
        if (!gameState.dynamicBonusStates[bonusId]) {
            gameState.dynamicBonusStates[bonusId] = {};
        }
        gameState.dynamicBonusStates[bonusId][triggerSynergy] = newCount;
        
        // Marquer comme incr√©ment√© ce round
        if (!gameState.dynamicBonusTriggers) {
            gameState.dynamicBonusTriggers = {};
        }
        gameState.dynamicBonusTriggers[bonusRoundKey] = true;
        
        console.log(`üéØ Bonus dynamique "${bonusDesc.name}" : compteur incr√©ment√© de ${currentCount} √† ${newCount} (synergie "${triggerSynergy}" - round ${gameState.currentCombat.round || 1})`);
    }
}

// Appliquer les bonus apr√®s combat
export function applyCombatBonuses(gameState) {
    // Compter les occurrences de chaque bonus
    const bonusCounts = {};
    gameState.unlockedBonuses.forEach(bonusId => {
        bonusCounts[bonusId] = (bonusCounts[bonusId] || 0) + 1;
    });
    
    // Bonus d'or uniquement
    if (bonusCounts['gold_bonus']) {
        const goldBonus = 25 * bonusCounts['gold_bonus'];
        gameState.addGold(goldBonus);
        // gameState.showNotification(`+${goldBonus} or (bonus)`, 'success');
    }
    
    // Les bonus de d√©g√¢ts (corps_a_corps_bonus, distance_bonus, magique_bonus) 
    // sont maintenant trait√©s comme des bonus d'√©quipement dans calculateEquipmentBonuses()
} 